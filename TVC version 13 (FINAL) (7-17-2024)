#include <Wire.h>                                //libraries
#include "Arduino_BMI270_BMM150.h"
#include <Servo.h>
Servo servoX;
Servo servoY;
Servo servochute;
int chutetimer = 0;                                   
int chuteout = 0;
float posX = 90;
float posY = 98;
unsigned long oldTime=0;
float Gyroangley = 0, Gyroanglex = 0;
float gyroX = 0, gyroY = 0;
float accelX = 0, accelY = 0;
float prevgyroX = 0, prevgyroY = 0;
float prevaccelX = 0, prevaccelY = 0;
float gyroYoffset= 0, gyroXoffset= 0;
float rawgyroY = 0, rawgyroX = 0;
float angleY= 0, angleX = 0;
int counter = 0;
int launchstart = 0;
float vertspeed;
float avraccelY = 0, avraccelX = 0;
float deltaTime;
float pastaccelY = 0, pastaccelX = 0;
float ax, ay, az;
float accelrateY, gyrorateY, accelrateX, gyrorateX;
float rateY= 0, rateX= 0;
float errorY = 0, errorX = 0;
float outX;
float outY;
float prevoutX;
float prevoutY;
float TVC_ChangeX;
float TVC_ChangeY;
float P = .3;                             // changeable PID values
float I = .01;
float D = .09;
void setup() {
  Wire.begin();
  Serial.begin(9600);
  if (!IMU.begin()) {
    Serial.println("Failed to initialize IMU!");
    while (1);
  }
  Serial.print("Gyroscope sample rate = ");                       //initalizing IMU 
  Serial.print(IMU.gyroscopeSampleRate());
  Serial.println(" Hz");
  Serial.println();
  Serial.println("Gyroscope in degrees/second");
  Serial.println("X\tY\tZ");
  servoX.attach(12);
  servoY.attach(10);
  servochute.attach(5);
  servochute.write(15);
  servoX.write(91);
  servoY.write(92.75);
  delay(5000);                                     // servo test 
   for (posX = 91; posX >= 65; posX -= 3) { 
    servoX.write(posX);             
  }
  delay(100);
  for (posY = 92.75; posY >= 75; posY -= 3) { 
    servoY.write(posY);                                 
  }
  delay(100);
  for (posX = 65; posX <= 90; posX += 3) { 
    servoX.write(posX);                                  
  }
  delay(100);
   for (posX = 90; posX <= 115; posX += 3) {
    servoX.write(posX);                               
  }
  delay(100);
  for (posY = 75; posY <= 100; posY += 3) { 
    servoY.write(posY);                           
  }
  delay(100);
  for (posY = 100; posY <= 125; posY += 3) { 
    servoY.write(posY);                                
  }
  delay(100);
   for (posX = 115; posX >= 91; posX -= 3) { 
    servoX.write(posX);                                  
  }
  delay(100);
   for (posY = 125; posY >= 92.75; posY -= 3) { 
    servoY.write(posY);                                  
  }
  delay(100);
  delay(9500);
}




void loop() {
float x, y, z;
  if (IMU.gyroscopeAvailable()) {
    IMU.readGyroscope(x, y, z);
  unsigned long currentTime = millis();
  unsigned long deltaTime = currentTime - oldTime;
  oldTime = currentTime;
  Gyroangley += (y*deltaTime)/1000;                              //convert gyro to degrees
  Gyroanglex += (x*deltaTime)/1000;
  rawgyroX = Gyroanglex;
  rawgyroY = Gyroangley;
  gyrorateY = (y+.1);
  gyrorateX = (x+.1);
  vertspeed = z;
  }
   if (IMU.accelerationAvailable()) {
    IMU.readAcceleration(ax, ay, az);                                  //convert acceleration to degrees/sec^2
  pastaccelY = (atan2(ax, sqrt(ay * ay + az * az)) * 180 / PI);
  pastaccelX = -(atan2(ay, sqrt(ax * ax + az * az)) * 180 / PI);
  }
  delay(30);
  if (IMU.accelerationAvailable()) {
    IMU.readAcceleration(ax, ay, az);
accelY = (atan2(ax, sqrt(ay * ay + az * az)) * 180 / PI);
accelX = -(atan2(ay, sqrt(ax * ax + az * az)) * 180 / PI);
  }
  if (counter>5){
  avraccelY = prevaccelY;                                                  // merge raw accel data and converted gyro data for more accurate position
  prevgyroY = gyroY;
  counter=1;
  prevaccelY = 0;
  avraccelX = prevaccelX;
  prevgyroX = gyroX;
  prevaccelX = 0;
  gyroXoffset = (rawgyroX - avraccelX);
  gyroYoffset = (rawgyroY- avraccelY);
  }
  else if (counter<3){
  counter = counter+1;
  prevaccelY=accelY;
  prevaccelX=accelX;
  gyroXoffset = (gyroXoffset+((gyroX-accelX)*.05));    
  gyroYoffset = (gyroYoffset+((gyroY-accelY)*.05));
  }
  else{
  counter = counter+1;
  prevaccelY=accelY;
  prevaccelX=accelX;  
  }
  // Read accelerometer and gyroscope data in degree
  gyroY = rawgyroY-gyroYoffset;
angleY = .45*gyroY + .55*accelY;                                                              // develop final angle measures to be used in PID
  gyroX = rawgyroX-gyroXoffset;
angleX = .45*gyroX + .55*accelX;
 Serial.print(angleY);
 Serial.print(" ");
  // Update previous angle value
accelrateY = 3.3*(accelY-pastaccelY);              
rateY = .1*(accelrateY)+.9*(gyrorateY);                                                      // develop accelerations for PID
accelrateX = 3.3*(accelX-pastaccelX);
rateX = .1*(accelrateX)+.9*(gyrorateX);
Serial.print(rateY);
Serial.print(" ");                                                                             
errorY += angleY;                                                                              // error for PID
errorX += angleX;
outX = -((P*angleX)+(I*errorX)+(D*rateX));                                                      // PID out
outY = ((P*angleY)+(I*errorY)+(D*rateY));
if (outX>35){                                                                             // fail states, if PID output greater than 35 degrees enter abort mode
  outX = 35;
  servochute.write(0);
  chuteout = 2;
}
if (outX<-35){
  outX = -35;
  servochute.write(0);
  chuteout = 2;
}
if (outY>35){
  outY = 35;
  servochute.write(0);
  chuteout = 2;
}
if (outY<-35){
  outY = -35;
  servochute.write(0);
  chuteout = 2;
}
//
if (launchstart < 1){                                           //detecting launch
if (vertspeed>2){
errorX = 0;
errorY = 0;
launchstart = 2;
}
if (vertspeed<-2){
errorX = 0;
errorY = 0;  
launchstart = 2;
}
chutetimer = chutetimer-1;
errorX = 0;
errorY = 0;
}
//
TVC_ChangeX = (outX-prevoutX);
TVC_ChangeY = (outY-prevoutY);
Serial.print(errorY);                                                              //servo command lines
Serial.println(" ");
if (TVC_ChangeX>0){
  if (TVC_ChangeX<2){
  for (posX = (prevoutX+91); posX <= (outX+91); posX += .5) { 
    // in steps of .5 degree
    servoX.write(posX);              // tell servo to go to position in variable 'pos'                      
  }
 }
 else if (TVC_ChangeX<4){
  for (posX = (prevoutX+91); posX <= (outX+91); posX += 1) { 
    // in steps of 1 degree
    servoX.write(posX);              // tell servo to go to position in variable 'pos'                      
  }
 }
  else if (TVC_ChangeX<10){
  for (posX = (prevoutX+91); posX <= (outX+91); posX += 2.5) { 
    // in steps of 2.5 degrees
    servoX.write(posX);              // tell servo to go to position in variable 'pos'                      
 }
  else{
  for (posX = (prevoutX+91); posX <= (outX+91); posX += 4) { 
    // in steps of 4 degrees
    servoX.write(posX);              // tell servo to go to position in variable 'pos'                      
  }
  }
}
else {
 if (TVC_ChangeX>-2){
 for (posX = (prevoutX+91); posX >= (outX+91); posX -= .5) { 
    // in steps of .5 degree
    servoX.write(posX);              // tell servo to go to position in variable 'pos'                    
  }
 }
 else if (TVC_ChangeX>-4){
   for (posX = (prevoutX+91); posX >= (outX+91); posX -= 1) { 
    // in steps of 1 degree
    servoX.write(posX);              // tell servo to go to position in variable 'pos'                      
  }
 }
 else if (TVC_ChangeX>-10){
   for (posX = (prevoutX+91); posX >= (outX+91); posX -= 2.5) { 
    // in steps of 2.5 degrees
    servoX.write(posX);              // tell servo to go to position in variable 'pos'                     
  }
 }
  else{
  for (posX = (prevoutX+91); posX >= (outX+91); posX -= 4) { 
    // in steps of 4 degrees
    servoX.write(posX);              // tell servo to go to position in variable 'pos'                      
  }
  }
}




if (TVC_ChangeY>0){
  if (TVC_ChangeY<2){
  for (posY = (prevoutY+92.75); posY <= (outY+92.75); posY += .5) { 
    // in steps of .5 degree
    servoY.write(posY);              // tell servo to go to position in variable 'pos'                      
  }
 }
 else if (TVC_ChangeY<4){
 for (posY = (prevoutY+92.75); posY <= (outY+92.75); posY += 1) { 
    // in steps of 1 degree
    servoY.write(posY);              // tell servo to go to position in variable 'pos'                      
  }
 }
  else if (TVC_ChangeY<10){
  for (posY = (prevoutY+92.75); posY <= (outY+92.75); posY += 2.5) { 
    // in steps of 2.5 degrees
    servoY.write(posY);              // tell servo to go to position in variable 'pos'                      
  }
 }
  else{
  for (posY = (prevoutY+92.75); posY <= (outY+92.75); posY += 4) { 
    // in steps of 4 degrees
    servoY.write(posY);              // tell servo to go to position in variable 'pos'                      
  }
  }
}
else if (TVC_ChangeY<0){
 if (TVC_ChangeY>-2){
 for (posY = (prevoutY+92.75); posY >= (outY+92.75); posY -= .5) { 
    // in steps of .5 degree
    servoY.write(posY);              // tell servo to go to position in variable 'pos'                     
  }
 }
 else if (TVC_ChangeY>-4){
   for (posY = (prevoutY+92.75); posY >= (outY+92.75); posY -= 1) { 
    // in steps of 1 degree
    servoY.write(posY);              // tell servo to go to position in variable 'pos'                      
  }
 }
 else if (TVC_ChangeY>-10){
    for (posY = (prevoutY+92.75); posY >= (outY+92.75); posY -= 2.5) { 
    // in steps of 2.5 degrees
    servoY.write(posY);              // tell servo to go to position in variable 'pos'                      
  }
 }
  else{
   for (posY = (prevoutY+92.75); posY >= (outY+92.75); posY -= 4) { 
    // in steps of 4 degrees
    servoY.write(posY);              // tell servo to go to position in variable 'pos'                      
  }
  }
}
prevoutX= outX;
prevoutY = outY;
if (chuteout<1){
if (chutetimer>95){                                            // chute deployment (Timer Based)
 servochute.write(0);
 chuteout = 2;
}
}
chutetimer = chutetimer+1;
}
